# -*- coding: utf-8 -*-
"""train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-O6zfcqY6XnWQpBXW2Sw4DDjXFSY9e5-
"""

#Importing modules
import numpy as np
from sklearn.metrics import confusion_matrix
from scipy.spatial.distance import cdist
from skimage.measure import label, regionprops, moments, moments_central, moments_normalized, moments_hu
from skimage import io, exposure, morphology
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import pickle

#Reading the image file
def readFile(img):
  img = io.imread(img)
  img.shape
  return img

#Visualizing the image/matrix
def visualizeImg(img):
  io.imshow(img)
  plt.title("Original Image")
  io.show()
  return img

#Image histogram
def showHist(img):
  hist = exposure.histogram(img)
  plt.bar(hist[1], hist[0])
  plt.title("Histogram")
  plt.show()

#Binarization by Thresholding
def binThreshold(img, num):
  th = num
  img_binary = (img < th).astype(np.double)
  
  #Dilating the image to fill out imperfections
  eroded_img = morphology.binary_erosion(img_binary)
  dilated_img = morphology.binary_dilation(eroded_img)
  dilated_img = morphology.binary_dilation(dilated_img)
  dilated_img = morphology.binary_dilation(dilated_img)
  io.imshow(img_binary)
  plt.title("Binary Image")
  io.show()
  return dilated_img

#Connected Component Analysis
def cca(img_binary):
  img_label = label(img_binary, background=0)
  io.imshow(img_label)
  plt.title("Labeled Image")
  io.show()
  return img_label

#Number of connected components in the image
#np.amax(img_label)

#Computing	Hu	Moments	and	Removing	Small	Components
def huMoments(img_binary, minr, minc, maxr, maxc):
  roi = img_binary[minr:maxr, minc:maxc]
  m = moments(roi)
  cc = m[0, 1] / m[0, 0]
  cr = m[1, 0] / m[0, 0]
  mu = moments_central(roi, center=(cr, cc))
  nu = moments_normalized(mu)
  hu = moments_hu(nu)
  hu
  return hu

#Storing features and displaying bouding boxes
#Features = []
def storeFeatures(img_label, img_binary, Features, character_class, num):
  
  min_height_th = 12  #12 or 9
  min_width_th = 12   #12 or 13
  regions = regionprops(img_label)
  ax = plt.gca()
  

  for props in regions:
    minr, minc, maxr, maxc = props.bbox
    height = maxr - minr
    width = maxc - minc
    if height >= min_height_th and width >= min_width_th:
      hu = huMoments(img_binary, minr, minc, maxr, maxc)
      Features.append(hu)
      character_class.append(num)
      ax.add_patch(Rectangle((minc, minr), maxc - minc, maxr - minr, fill=False, edgecolor='red', linewidth=1))

  binary_img = np.isin(img_label, Features).astype(np.uint8) * 255
  io.imshow(img_binary)
  ax.set_title("Bounding Boxes")
  io.show()
  return Features