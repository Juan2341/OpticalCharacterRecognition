# -*- coding: utf-8 -*-
"""trainingDatabase.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zc2kJWVT9RQHH7erYGq3sHXhfnEY6VFO
"""

import train
import numpy as np
from sklearn.metrics import confusion_matrix
from scipy.spatial.distance import cdist
from skimage.measure import label, regionprops, moments, moments_central, moments_normalized, moments_hu
from skimage import io, exposure
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import pickle
import cv2

Features = []
img_list = ['a.bmp', 'd.bmp', 'm.bmp', 'n.bmp', 'o.bmp', 'p.bmp', 'q.bmp', 'r.bmp', 'u.bmp', 'w.bmp']
character_class = []
num = 1

#Use morhpohology after thresholding
for imgName in img_list:

  img = train.readFile(imgName)
  vis_img = train.visualizeImg(img)
  train.showHist(img)
  img_binary = train.binThreshold(img, 205)   #205: Correct th before enhancements
  img_label = train.cca(img_binary)
  Features = train.storeFeatures(img_label, img_binary, Features, character_class, num)
  num += 1

#Normalization
Features_Array = np.array(Features)
ft_means = np.mean(Features_Array, axis = 0)
ft_sds = np.std(Features_Array, axis = 0)
nFeatures = (Features_Array - ft_means) / ft_sds



#Recognition on Training Data
D = cdist(nFeatures, nFeatures)
io.imshow(D)
plt.title("Distance Matrix")
io.show()

D_index = np.argsort(D, axis=1)

correct_predictions = 0
k = 1
for i in range(len(D_index)):
  nearest_indices = D_index[i, 1:k+1]
  nearest_labels = [character_class[idx2] for idx2 in nearest_indices]
  predicted_label = max(set(nearest_labels), key=nearest_labels.count)
  if predicted_label == character_class[i]:
    correct_predictions += 1

recognition_rate = correct_predictions / len(Features)
print(f"Recognition rate: {recognition_rate * 100:.2f}%")

#Confusion Matrix
confM = confusion_matrix(character_class, [character_class[idx] for idx in np.argmin(D, axis=1)])
io.imshow(confM)
plt.title('Confusion Matrix')
io.show()

